<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<meta name="google-adsense-account" content="ca-pub-9634304134787821">
	<title>Minecraft Skin Overlay Merger</title>
	<style>
		:root { --bg:#0f1220; --panel:#171a2b; --muted:#8b92b2; --accent:#6de39b; --danger:#ff6b6b; --light:#eef1ff; --grid:rgba(255,255,255,0.15); }
		html,body{background:radial-gradient(1200px 600px at 70% -10%,#1a1f39 0%,#0f1220 60%) fixed;color:var(--light);font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";margin:0;height:100%}
		.container{max-width:980px;margin:32px auto;padding:0 16px}
		h1{font-size:22px;margin:0 0 16px;font-weight:700}
		.sub{color:var(--muted);margin-bottom:20px}
		.grid{display:grid;grid-template-columns:repeat(2,1fr);gap:16px}
		@media(max-width:720px){.grid{grid-template-columns:1fr}}
		.card{background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.08);border-radius:12px;padding:14px;backdrop-filter:blur(6px)}
		.drop{border:2px dashed rgba(255,255,255,0.18);border-radius:12px;padding:14px;display:grid;grid-template-columns:120px 1fr;gap:14px;align-items:center;transition:border-color .2s,background .2s}
		.drop.dragover{border-color:var(--accent);background:rgba(109,227,155,0.07)}
		.preview{width:120px;height:120px;border-radius:8px;position:relative;background:linear-gradient(45deg,var(--grid)25%,transparent 25%) 0 0/16px 16px, linear-gradient(-45deg,var(--grid)25%,transparent 25%) 0 8px/16px 16px, linear-gradient(45deg,transparent 75%,var(--grid)75%) 8px -8px/16px 16px, linear-gradient(-45deg,transparent 75%,var(--grid)75%) -8px 0/16px 16px,#22263d;display:grid;place-items:center;overflow:hidden;border:1px solid rgba(255,255,255,0.1);transition:transform .12s ease,border-color .12s ease,box-shadow .12s ease}
		.preview img{max-width:100%;max-height:100%;image-rendering:pixelated;display:block}
		.preview:hover{transform:scale(1.04);border-color:var(--accent);box-shadow:0 8px 30px rgba(13,160,109,0.08)}
		.preview::after{content:"Preview";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) translateY(8px);background:rgba(8,10,18,0.65);color:#dfffe9;font-size:12px;padding:6px 10px;border-radius:8px;opacity:0;transition:opacity .16s ease,transform .16s ease;pointer-events:none;backdrop-filter:blur(4px)}
		.preview:hover::after{opacity:1;transform:translate(-50%,-50%) translateY(0)}
		.controls{display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between;margin-top:16px}
		.left,.right{display:flex;gap:12px;align-items:center}
		.btn{background:linear-gradient(180deg,#7ff0b0,#63d994);color:#0b1320;border:none;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(99,217,148,.25);transition:transform .06s ease,filter .15s ease}
		.btn:hover{filter:brightness(1.05)}.btn:active{transform:translateY(1px)}.btn.secondary{background:transparent;color:var(--light);border:1px solid rgba(255,255,255,0.18);box-shadow:none}
		label.file{display:inline-flex;align-items:center;gap:10px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.14);padding:8px 12px;border-radius:10px;cursor:pointer}
		input[type=file]{display:none}.note{color:var(--muted);font-size:13px}.error{color:var(--danger);font-weight:600;margin-top:6px}
		.checkbox{display:inline-flex;gap:8px;align-items:center;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.14);padding:8px 12px;border-radius:10px}
		footer{margin-top:18px;color:var(--muted);font-size:13px}code.k{background:rgba(255,255,255,0.08);padding:2px 6px;border-radius:6px}

		/* Modal: keep 16:9 preview canvas + controls */
		#preview-modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(6,8,16,0.6);z-index:9999;padding:24px}
		#preview-panel{width:min(1280px,96%);max-height:94%;background:#0f1220;border-radius:12px;overflow:hidden;border:1px solid rgba(255,255,255,0.06);box-shadow:0 24px 80px rgba(0,0,0,0.7);display:grid;grid-template-columns:1fr 360px}
		#preview-header{padding:12px 14px;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid rgba(255,255,255,0.03)}
		/* responsive 16:9 canvas — CSS keeps aspect, JS uses clientWidth/clientHeight */
		#preview-canvas{width:100%;aspect-ratio:16/9;background:#0b0d18;display:block}
		#preview-body{padding:16px;color:var(--muted);font-size:14px;overflow:auto}
		#preview-close{background:transparent;border:0;color:var(--light);cursor:pointer;font-weight:700;padding:6px 8px;border-radius:8px}
		#preview-header .controls{gap:8px}
		@media(max-width:1000px){#preview-panel{grid-template-columns:1fr}#preview-canvas{height:48vw;aspect-ratio:auto}}
		#bg-name{font-size:13px;color:var(--muted);margin-left:8px}
		.select, .small { background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06); color:var(--light); padding:6px 8px; border-radius:8px }
		.range { width:140px }
	</style>

	<!-- load THREE first so skinview3d can reuse it -->
	<script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
	<!-- skinview3d -->
	<script src="https://unpkg.com/skinview3d@2.2.0/bundles/skinview3d.bundle.js"></script>
</head>
<body>
	<div class="container">
		<h1>Minecraft Skin Overlay Merger</h1>
		<div class="sub">Drop your <b>Base Skin</b> PNG and your <b>Overlay (2nd layer)</b> PNG. We’ll merge them client-side (no upload).</div>

		<div class="grid">
			<div class="card">
				<h3>Base Skin</h3>
				<div id="drop-base" class="drop">
					<div class="preview"><img id="img-base" alt="Base preview" title="Click to preview 3D" /></div>
					<div>
						<div class="note">PNG recommended 64×64. Old 64×32 also works if both match.</div>
						<div style="margin-top:10px">
							<label class="file"><input id="file-base" type="file" accept="image/png" /><span>Choose PNG…</span></label>
						</div>
						<div id="err-base" class="error" style="display:none"></div>
					</div>
				</div>
			</div>

			<div class="card">
				<h3>Overlay (2nd layer)</h3>
				<div id="drop-ovr" class="drop">
					<div class="preview"><img id="img-ovr" alt="Overlay preview" title="Click to preview 3D" /></div>
					<div>
						<div class="note">Transparent PNG with only 2nd layer pixels (hat, jacket, sleeves, pants).</div>
						<div style="margin-top:10px">
							<label class="file"><input id="file-ovr" type="file" accept="image/png" /><span>Choose PNG…</span></label>
						</div>
						<div id="err-ovr" class="error" style="display:none"></div>
					</div>
				</div>
			</div>
		</div>

		<div class="controls">
			<div class="left">
				<label class="checkbox"><input id="auto-resize" type="checkbox" /><span>Auto-resize overlay to base size</span></label>
				<label class="checkbox" style="margin-left:8px"><input id="preserve-filename" type="checkbox" checked /><span>Use base filename</span></label>
			</div>

			<div class="right">
				<button id="btn-preview" class="btn secondary">Preview</button>
				<button id="btn-merge" class="btn">Merge & Download</button>
				<button id="btn-clear" class="btn secondary">Clear</button>
			</div>
		</div>

		<footer>Tip: If your overlay image includes base-layer pixels, they’ll still be composited. For strict 2nd-layer validation, preprocess your overlay in an editor and erase unwanted pixels (use <code class="k">nearest-neighbor</code> / “pixelated” to avoid blur).</footer>
	</div>

	<canvas id="canvas" width="64" height="64" style="display:none"></canvas>

	<!-- 3D preview modal with BG controls in header -->
	<div id="preview-modal" role="dialog" aria-hidden="true">
		<div id="preview-panel">
			<div>
				<div id="preview-header">
					<div style="font-weight:800;color:var(--light)">3D Skin Preview</div>
					<div class="controls">
						<label class="file" title="Upload a background image for the preview">
							<input id="preview-file-bg" type="file" accept="image/*" />
							<span>Upload BG</span>
						</label>
						<select id="bg-fit" class="select small" title="Fit mode">
							<option value="cover">Cover</option>
							<option value="contain">Contain</option>
							<option value="stretch">Stretch</option>
						</select>
						<select id="bg-filter" class="select small" title="Interpolation/Filter">
							<option value="linear">Linear</option>
							<option value="nearest">Nearest</option>
						</select>
						<label class="small">Zoom <input id="bg-scale" class="range" type="range" min="0.5" max="2" step="0.01" value="1" /></label>
						<span id="bg-name"></span>
						<button id="preview-bg-remove" class="btn secondary" style="display:none">Remove BG</button>
						<button id="preview-close" title="Close">✕</button>
					</div>
				</div>
				<canvas id="preview-canvas" width="1280" height="720"></canvas>
			</div>
			<div id="preview-body">
				<p id="preview-desc" style="margin-top:6px;color:var(--muted)">Loading...</p>
				<p style="margin-top:12px;color:var(--muted)">Controls: drag to rotate, scroll to zoom, double-click to recenter.</p>
			</div>
		</div>
	</div>

	<script>
		/* ---------- Utilities ---------- */
		function fileToImage(file) { return new Promise((resolve,reject)=>{ const r=new FileReader(); r.onerror=()=>reject(new Error("Failed to read file")); r.onload=()=>{ const img=new Image(); img.onload=()=>resolve(img); img.onerror=()=>reject(new Error("Failed to decode image")); img.src=r.result; }; r.readAsDataURL(file); }); }
		function fileToDataUrl(file){ return new Promise((resolve,reject)=>{ const r=new FileReader(); r.onerror=()=>reject(new Error("Failed to read file")); r.onload=()=>resolve(r.result); r.readAsDataURL(file); }); }
		function ensureImageReady(img){ return new Promise(resolve=>{ if(!img) return resolve(false); if(img.complete && img.naturalWidth && img.naturalHeight) return resolve(true); img.addEventListener('load',()=>resolve(true),{once:true}); img.addEventListener('error',()=>resolve(false),{once:true}); }); }
		function raf(){ return new Promise(r=>requestAnimationFrame(r)); }

		/* ---------- State & Elements ---------- */
		let baseImg=null, overlayImg=null, baseName='base';
		let bgDataUrl=null; let viewer=null; let bgTexture=null;

		const dropBase=document.getElementById('drop-base');
		const dropOvr=document.getElementById('drop-ovr');
		const imgBase=document.getElementById('img-base');
		const imgOvr=document.getElementById('img-ovr');
		const fileBase=document.getElementById('file-base');
		const fileOvr=document.getElementById('file-ovr');
		const fileCanvas=document.getElementById('canvas');
		const ctx=fileCanvas.getContext('2d',{willReadFrequently:false});
		const autoResize=document.getElementById('auto-resize');
		const preserveFilename=document.getElementById('preserve-filename');
		const btnMerge=document.getElementById('btn-merge');
		const btnPreview=document.getElementById('btn-preview');
		const btnClear=document.getElementById('btn-clear');
		const errBase=document.getElementById('err-base');
		const errOvr=document.getElementById('err-ovr');

		const previewModal=document.getElementById('preview-modal');
		const previewCanvas=document.getElementById('preview-canvas');
		const previewDesc=document.getElementById('preview-desc');
		const previewClose=document.getElementById('preview-close');
		const previewFileBg=document.getElementById('preview-file-bg');
		const previewBgRemove=document.getElementById('preview-bg-remove');
		const bgNameEl=document.getElementById('bg-name');
		const bgFilterSel=document.getElementById('bg-filter');
		const bgFitSel=document.getElementById('bg-fit');
		const bgScaleInp=document.getElementById('bg-scale');

		function setError(el,msg){ el.textContent = msg || ''; el.style.display = msg ? 'block' : 'none'; }

		/* ---------- Drag & Drop wiring ---------- */
		function wireDrop(zone,kind){ ['dragenter','dragover'].forEach(ev=>zone.addEventListener(ev,e=>{e.preventDefault();e.stopPropagation();zone.classList.add('dragover');})); ['dragleave','drop'].forEach(ev=>zone.addEventListener(ev,e=>{e.preventDefault();e.stopPropagation();zone.classList.remove('dragover');})); zone.addEventListener('drop', e=>{ handleFiles(kind,e.dataTransfer.files); }); }
		wireDrop(dropBase,'base'); wireDrop(dropOvr,'ovr'); fileBase.addEventListener('change', e=>handleFiles('base', e.target.files)); fileOvr.addEventListener('change', e=>handleFiles('ovr', e.target.files));

		async function handleFiles(kind, files){ const file = files && files[0]; if(!file) return; if(!file.type || (!file.type.includes('png') && !file.type.includes('image'))) { kind==='base'? setError(errBase,'Please select a PNG.') : setError(errOvr,'Please select a PNG.'); return; } kind==='base'? setError(errBase,'') : setError(errOvr,''); if(kind==='base') baseName = (file.name||'base').replace(/\.png$/i,''); try{ const img = await fileToImage(file); if(kind==='base'){ baseImg = img; imgBase.src = img.src; } else { overlayImg = img; imgOvr.src = img.src; } } catch(err){ console.error(err); kind==='base'? setError(errBase,err.message) : setError(errOvr,err.message); } }

		/* ---------- Compositing helpers ---------- */
		function compositeToCanvas(){ if(!baseImg || !overlayImg) return null; const bw=baseImg.width,bh=baseImg.height,ow=overlayImg.width,oh=overlayImg.height; fileCanvas.width=bw; fileCanvas.height=bh; ctx.clearRect(0,0,bw,bh); ctx.imageSmoothingEnabled=false; drawImageSafe(ctx, baseImg,0,0,bw,bh); if(bw===ow && bh===oh) drawImageSafe(ctx, overlayImg,0,0); else if(autoResize.checked) ctx.drawImage(overlayImg,0,0,ow,oh,0,0,bw,bh); else { setError(errOvr, `Size mismatch: overlay is ${ow}×${oh}, base is ${bw}×${bh}. Enable "Auto-resize overlay" or provide matching sizes.`); return null; } return fileCanvas; }
		function overlayOnlyDataUrl(){ if(!overlayImg) return null; const tmp=document.createElement('canvas'); tmp.width=overlayImg.width; tmp.height=overlayImg.height; const t=tmp.getContext('2d'); t.imageSmoothingEnabled=false; t.clearRect(0,0,tmp.width,tmp.height); t.drawImage(overlayImg,0,0); return tmp.toDataURL('image/png'); }
		function drawImageSafe(c,img,x=0,y=0,w=img.width,h=img.height){ try{ c.drawImage(img,x,y,w,h); } catch(e){ console.warn('drawImage failed',e); } }

		/* ---------- 3D viewer & background ---------- */
		const { SkinViewer, createOrbitControls } = skinview3d;

		function openModal(){ previewModal.style.display='flex'; previewModal.setAttribute('aria-hidden','false'); window.addEventListener('resize', onWindowResizeWhileOpen); }
		function closeModal(){ previewModal.style.display='none'; previewModal.setAttribute('aria-hidden','true'); window.removeEventListener('resize', onWindowResizeWhileOpen); }
		previewClose.addEventListener('click', closeModal); previewModal.addEventListener('click', e => { if(e.target === previewModal) closeModal(); });

		function resizeViewerCanvasToDisplaySize(v){ const dpr = Math.min(window.devicePixelRatio||1,2); const cw = Math.max(1, Math.floor(previewCanvas.clientWidth * dpr)); const ch = Math.max(1, Math.floor(previewCanvas.clientHeight * dpr)); previewCanvas.width = cw; previewCanvas.height = ch; if(v && v.renderer){ try{ v.renderer.setSize(cw,ch,false); }catch(e){} } if(v && v.camera){ try{ v.camera.aspect = cw / ch; v.camera.updateProjectionMatrix(); }catch(e){} } }

		function ensureViewer(){ if(viewer) return viewer; viewer = new SkinViewer({ canvas: previewCanvas, width: previewCanvas.width, height: previewCanvas.height, skin:null }); viewer.zoom = 0.9; viewer.fov = 50; createOrbitControls(viewer); return viewer; }

		function updateAndApplyBgOptions(tex){
			if(!tex || !tex.image) return;
			const filter = bgFilterSel.value; const fit = bgFitSel.value; const scale = Number(bgScaleInp.value) || 1;
			// filtering
			tex.magFilter = (filter === 'nearest') ? THREE.NearestFilter : THREE.LinearFilter;
			tex.minFilter = (filter === 'nearest') ? THREE.NearestMipmapNearestFilter : THREE.LinearMipmapLinearFilter;
			tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping; // default
			// compute repeat/offset to mimic cover/contain/ stretch + zoom (scale)
			const canvasW = previewCanvas.clientWidth; const canvasH = previewCanvas.clientHeight; const cA = canvasW / canvasH; const iW = tex.image.width; const iH = tex.image.height; const iA = iW / iH;
			let repeatX = 1, repeatY = 1; if(fit === 'stretch') { repeatX = scale; repeatY = scale; tex.repeat.set(repeatX, repeatY); tex.center.set(0.5,0.5); tex.offset.set((1-repeatX)/2, (1-repeatY)/2); return; }
			if(fit === 'cover'){
				// scale so texture covers the canvas — we adjust repeat to crop the extra
				if(iA > cA){ // image wider than canvas -> scale Y so height fits, crop X
					repeatY = 1 / scale; repeatX = iA / cA * repeatY;
				} else { // image taller than canvas -> scale X so width fits, crop Y
					repeatX = 1 / scale; repeatY = cA / iA * repeatX;
				}
			} else { // contain: fit whole image inside canvas
				if(iA > cA){ // image wider -> width fits, show full width -> Y gets extra letterbox
					repeatX = 1 / scale; repeatY = cA / iA * repeatX;
				} else {
					repeatY = 1 / scale; repeatX = iA / cA * repeatY;
				}
			}
			// clamp small positives
			repeatX = Math.max(0.0001, repeatX); repeatY = Math.max(0.0001, repeatY);
			tex.repeat.set(repeatX, repeatY);
			// center the texture
			tex.center.set(0.5,0.5);
			tex.offset.set((1 - repeatX)/2, (1 - repeatY)/2);
		}

		function applyBackgroundToViewer(v){ if(!v || !v.scene) return; if(!bgDataUrl){ if(v.scene) v.scene.background = null; bgTexture = null; return; }
			const loader = new THREE.TextureLoader();
			loader.load(bgDataUrl,
				(tex) => { try { tex.encoding = THREE.sRGBEncoding; tex.needsUpdate = true; bgTexture = tex; updateAndApplyBgOptions(tex); v.scene.background = tex; } catch(e){ console.error('bg apply err', e); } },
				undefined,
				(err) => { console.error('bg load failed', err); }
			);
		}

		async function showSkinIn3D(dataUrl, descText){ if(!dataUrl){ alert('No skin available to preview.'); return; } openModal(); previewDesc.textContent = 'Loading preview...'; await raf(); const v = ensureViewer(); resizeViewerCanvasToDisplaySize(v); applyBackgroundToViewer(v); try{ await v.loadSkin(dataUrl); previewDesc.textContent = descText || ''; } catch(err){ console.error('loadSkin error', err); previewDesc.textContent = 'Failed to load skin.'; } }

		function onWindowResizeWhileOpen(){ if(!previewModal || previewModal.style.display !== 'flex') return; if(!viewer) return; resizeViewerCanvasToDisplaySize(viewer); // re-calc bg layout if needed
			if(bgTexture) updateAndApplyBgOptions(bgTexture); }

		/* ---------- modal BG uploader & controls ---------- */
		previewFileBg.addEventListener('change', async (e) => { const f = e.target.files && e.target.files[0]; if(!f) return; if(!f.type || !f.type.startsWith('image/')){ alert('Please upload an image file.'); return; } try{ bgDataUrl = await fileToDataUrl(f); bgNameEl.textContent = f.name; previewBgRemove.style.display = 'inline-block'; if(viewer && previewModal.style.display === 'flex') applyBackgroundToViewer(viewer); } catch(err){ console.error(err); bgDataUrl = null; bgNameEl.textContent = ''; previewBgRemove.style.display = 'none'; } });
		previewBgRemove.addEventListener('click', () => { bgDataUrl = null; bgNameEl.textContent = ''; previewFileBg.value = ''; previewBgRemove.style.display = 'none'; if(viewer && viewer.scene) viewer.scene.background = null; bgTexture = null; });

		// when user tweaks bg options, update texture application immediately if bg loaded
		bgFilterSel.addEventListener('change', () => { if(bgTexture && viewer) { updateAndApplyBgOptions(bgTexture); viewer.scene.background = bgTexture; } });
		bgFitSel.addEventListener('change', () => { if(bgTexture && viewer) { updateAndApplyBgOptions(bgTexture); viewer.scene.background = bgTexture; } });
		bgScaleInp.addEventListener('input', () => { if(bgTexture && viewer) { updateAndApplyBgOptions(bgTexture); viewer.scene.background = bgTexture; } });

		/* ---------- Click handlers that wait for image readiness ---------- */
		imgBase.addEventListener('click', async () => { if(!baseImg){ setError(errBase, 'Please load a base skin PNG.'); return; } const ok = await ensureImageReady(baseImg); if(!ok){ setError(errBase, 'Base image not ready.'); return; } showSkinIn3D(baseImg.src, 'Base skin preview'); });
		imgOvr.addEventListener('click', async () => { if(!overlayImg){ setError(errOvr, 'Please load an overlay PNG.'); return; } const ok = await ensureImageReady(overlayImg); if(!ok){ setError(errOvr, 'Overlay image not ready.'); return; } showSkinIn3D(overlayOnlyDataUrl(), 'Overlay-only preview (transparent background)'); });
		btnPreview.addEventListener('click', async () => { if(!baseImg){ setError(errBase, 'Please load a base skin PNG.'); return; } if(!overlayImg){ setError(errOvr, 'Please load an overlay PNG.'); return; } const ok1 = await ensureImageReady(baseImg); const ok2 = await ensureImageReady(overlayImg); if(!ok1 || !ok2){ setError(errBase, 'Images are not ready yet.'); return; } const c = compositeToCanvas(); if(!c) return; showSkinIn3D(c.toDataURL('image/png'), 'Merged skin (base + overlay)'); });

		/* ---------- Merge & Clear (unchanged behavior) ---------- */
		btnMerge.addEventListener('click', () => { setError(errBase,''); setError(errOvr,''); if(!baseImg){ setError(errBase,'Please load a base skin PNG.'); return; } if(!overlayImg){ setError(errOvr,'Please load an overlay PNG.'); return; } const bw=baseImg.width,bh=baseImg.height,ow=overlayImg.width,oh=overlayImg.height; fileCanvas.width=bw; fileCanvas.height=bh; ctx.clearRect(0,0,bw,bh); ctx.imageSmoothingEnabled=false; drawImageSafe(ctx, baseImg,0,0,bw,bh); if(bw===ow && bh===oh) drawImageSafe(ctx, overlayImg,0,0); else if(autoResize.checked) ctx.drawImage(overlayImg,0,0,ow,oh,0,0,bw,bh); else { setError(errOvr, `Size mismatch: overlay is ${ow}×${oh}, base is ${bw}×${bh}. Enable "Auto-resize overlay" or provide matching sizes.`); return; } const outName = (preserveFilename.checked ? baseName : 'merged_skin') + '.png'; fileCanvas.toBlob(blob => { if(!blob) return; const a=document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = outName; document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove(); }, 'image/png'); });

		btnClear.addEventListener('click', () => { baseImg=null; overlayImg=null; baseName='base'; imgBase.removeAttribute('src'); imgOvr.removeAttribute('src'); setError(errBase,''); setError(errOvr,''); ctx.clearRect(0,0,fileCanvas.width,fileCanvas.height); bgDataUrl=null; bgNameEl.textContent=''; previewFileBg.value=''; previewBgRemove.style.display='none'; if(viewer && viewer.scene){ try{ viewer.scene.background=null; viewer.loadSkin((()=>{ const b=document.createElement('canvas'); b.width=1; b.height=1; return b.toDataURL(); })()); }catch(e){} } });
	</script>
</body>
</html>
